// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	context "context"

	graph "github.com/platform-mesh/iam-service/pkg/graph"
	mock "github.com/stretchr/testify/mock"
)

// ResolverService is an autogenerated mock type for the ResolverService type
type ResolverService struct {
	mock.Mock
}

type ResolverService_Expecter struct {
	mock *mock.Mock
}

func (_m *ResolverService) EXPECT() *ResolverService_Expecter {
	return &ResolverService_Expecter{mock: &_m.Mock}
}

// AssignRolesToUsers provides a mock function with given fields: ctx, _a1, changes
func (_m *ResolverService) AssignRolesToUsers(ctx context.Context, _a1 graph.ResourceContext, changes []*graph.UserRoleChange) (*graph.RoleAssignmentResult, error) {
	ret := _m.Called(ctx, _a1, changes)

	if len(ret) == 0 {
		panic("no return value specified for AssignRolesToUsers")
	}

	var r0 *graph.RoleAssignmentResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, graph.ResourceContext, []*graph.UserRoleChange) (*graph.RoleAssignmentResult, error)); ok {
		return rf(ctx, _a1, changes)
	}
	if rf, ok := ret.Get(0).(func(context.Context, graph.ResourceContext, []*graph.UserRoleChange) *graph.RoleAssignmentResult); ok {
		r0 = rf(ctx, _a1, changes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*graph.RoleAssignmentResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, graph.ResourceContext, []*graph.UserRoleChange) error); ok {
		r1 = rf(ctx, _a1, changes)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResolverService_AssignRolesToUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssignRolesToUsers'
type ResolverService_AssignRolesToUsers_Call struct {
	*mock.Call
}

// AssignRolesToUsers is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 graph.ResourceContext
//   - changes []*graph.UserRoleChange
func (_e *ResolverService_Expecter) AssignRolesToUsers(ctx interface{}, _a1 interface{}, changes interface{}) *ResolverService_AssignRolesToUsers_Call {
	return &ResolverService_AssignRolesToUsers_Call{Call: _e.mock.On("AssignRolesToUsers", ctx, _a1, changes)}
}

func (_c *ResolverService_AssignRolesToUsers_Call) Run(run func(ctx context.Context, _a1 graph.ResourceContext, changes []*graph.UserRoleChange)) *ResolverService_AssignRolesToUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(graph.ResourceContext), args[2].([]*graph.UserRoleChange))
	})
	return _c
}

func (_c *ResolverService_AssignRolesToUsers_Call) Return(_a0 *graph.RoleAssignmentResult, _a1 error) *ResolverService_AssignRolesToUsers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ResolverService_AssignRolesToUsers_Call) RunAndReturn(run func(context.Context, graph.ResourceContext, []*graph.UserRoleChange) (*graph.RoleAssignmentResult, error)) *ResolverService_AssignRolesToUsers_Call {
	_c.Call.Return(run)
	return _c
}

// Me provides a mock function with given fields: ctx
func (_m *ResolverService) Me(ctx context.Context) (*graph.User, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Me")
	}

	var r0 *graph.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*graph.User, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *graph.User); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*graph.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResolverService_Me_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Me'
type ResolverService_Me_Call struct {
	*mock.Call
}

// Me is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ResolverService_Expecter) Me(ctx interface{}) *ResolverService_Me_Call {
	return &ResolverService_Me_Call{Call: _e.mock.On("Me", ctx)}
}

func (_c *ResolverService_Me_Call) Run(run func(ctx context.Context)) *ResolverService_Me_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *ResolverService_Me_Call) Return(_a0 *graph.User, _a1 error) *ResolverService_Me_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ResolverService_Me_Call) RunAndReturn(run func(context.Context) (*graph.User, error)) *ResolverService_Me_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveRole provides a mock function with given fields: ctx, _a1, input
func (_m *ResolverService) RemoveRole(ctx context.Context, _a1 graph.ResourceContext, input graph.RemoveRoleInput) (*graph.RoleRemovalResult, error) {
	ret := _m.Called(ctx, _a1, input)

	if len(ret) == 0 {
		panic("no return value specified for RemoveRole")
	}

	var r0 *graph.RoleRemovalResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, graph.ResourceContext, graph.RemoveRoleInput) (*graph.RoleRemovalResult, error)); ok {
		return rf(ctx, _a1, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, graph.ResourceContext, graph.RemoveRoleInput) *graph.RoleRemovalResult); ok {
		r0 = rf(ctx, _a1, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*graph.RoleRemovalResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, graph.ResourceContext, graph.RemoveRoleInput) error); ok {
		r1 = rf(ctx, _a1, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResolverService_RemoveRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveRole'
type ResolverService_RemoveRole_Call struct {
	*mock.Call
}

// RemoveRole is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 graph.ResourceContext
//   - input graph.RemoveRoleInput
func (_e *ResolverService_Expecter) RemoveRole(ctx interface{}, _a1 interface{}, input interface{}) *ResolverService_RemoveRole_Call {
	return &ResolverService_RemoveRole_Call{Call: _e.mock.On("RemoveRole", ctx, _a1, input)}
}

func (_c *ResolverService_RemoveRole_Call) Run(run func(ctx context.Context, _a1 graph.ResourceContext, input graph.RemoveRoleInput)) *ResolverService_RemoveRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(graph.ResourceContext), args[2].(graph.RemoveRoleInput))
	})
	return _c
}

func (_c *ResolverService_RemoveRole_Call) Return(_a0 *graph.RoleRemovalResult, _a1 error) *ResolverService_RemoveRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ResolverService_RemoveRole_Call) RunAndReturn(run func(context.Context, graph.ResourceContext, graph.RemoveRoleInput) (*graph.RoleRemovalResult, error)) *ResolverService_RemoveRole_Call {
	_c.Call.Return(run)
	return _c
}

// Roles provides a mock function with given fields: ctx, _a1
func (_m *ResolverService) Roles(ctx context.Context, _a1 graph.ResourceContext) ([]*graph.Role, error) {
	ret := _m.Called(ctx, _a1)

	if len(ret) == 0 {
		panic("no return value specified for Roles")
	}

	var r0 []*graph.Role
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, graph.ResourceContext) ([]*graph.Role, error)); ok {
		return rf(ctx, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, graph.ResourceContext) []*graph.Role); ok {
		r0 = rf(ctx, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*graph.Role)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, graph.ResourceContext) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResolverService_Roles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Roles'
type ResolverService_Roles_Call struct {
	*mock.Call
}

// Roles is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 graph.ResourceContext
func (_e *ResolverService_Expecter) Roles(ctx interface{}, _a1 interface{}) *ResolverService_Roles_Call {
	return &ResolverService_Roles_Call{Call: _e.mock.On("Roles", ctx, _a1)}
}

func (_c *ResolverService_Roles_Call) Run(run func(ctx context.Context, _a1 graph.ResourceContext)) *ResolverService_Roles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(graph.ResourceContext))
	})
	return _c
}

func (_c *ResolverService_Roles_Call) Return(_a0 []*graph.Role, _a1 error) *ResolverService_Roles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ResolverService_Roles_Call) RunAndReturn(run func(context.Context, graph.ResourceContext) ([]*graph.Role, error)) *ResolverService_Roles_Call {
	_c.Call.Return(run)
	return _c
}

// User provides a mock function with given fields: ctx, userID
func (_m *ResolverService) User(ctx context.Context, userID string) (*graph.User, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for User")
	}

	var r0 *graph.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*graph.User, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *graph.User); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*graph.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResolverService_User_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'User'
type ResolverService_User_Call struct {
	*mock.Call
}

// User is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *ResolverService_Expecter) User(ctx interface{}, userID interface{}) *ResolverService_User_Call {
	return &ResolverService_User_Call{Call: _e.mock.On("User", ctx, userID)}
}

func (_c *ResolverService_User_Call) Run(run func(ctx context.Context, userID string)) *ResolverService_User_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *ResolverService_User_Call) Return(_a0 *graph.User, _a1 error) *ResolverService_User_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ResolverService_User_Call) RunAndReturn(run func(context.Context, string) (*graph.User, error)) *ResolverService_User_Call {
	_c.Call.Return(run)
	return _c
}

// Users provides a mock function with given fields: ctx, _a1, roleFilters, sortBy, page
func (_m *ResolverService) Users(ctx context.Context, _a1 graph.ResourceContext, roleFilters []string, sortBy *graph.SortByInput, page *graph.PageInput) (*graph.UserConnection, error) {
	ret := _m.Called(ctx, _a1, roleFilters, sortBy, page)

	if len(ret) == 0 {
		panic("no return value specified for Users")
	}

	var r0 *graph.UserConnection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, graph.ResourceContext, []string, *graph.SortByInput, *graph.PageInput) (*graph.UserConnection, error)); ok {
		return rf(ctx, _a1, roleFilters, sortBy, page)
	}
	if rf, ok := ret.Get(0).(func(context.Context, graph.ResourceContext, []string, *graph.SortByInput, *graph.PageInput) *graph.UserConnection); ok {
		r0 = rf(ctx, _a1, roleFilters, sortBy, page)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*graph.UserConnection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, graph.ResourceContext, []string, *graph.SortByInput, *graph.PageInput) error); ok {
		r1 = rf(ctx, _a1, roleFilters, sortBy, page)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResolverService_Users_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Users'
type ResolverService_Users_Call struct {
	*mock.Call
}

// Users is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 graph.ResourceContext
//   - roleFilters []string
//   - sortBy *graph.SortByInput
//   - page *graph.PageInput
func (_e *ResolverService_Expecter) Users(ctx interface{}, _a1 interface{}, roleFilters interface{}, sortBy interface{}, page interface{}) *ResolverService_Users_Call {
	return &ResolverService_Users_Call{Call: _e.mock.On("Users", ctx, _a1, roleFilters, sortBy, page)}
}

func (_c *ResolverService_Users_Call) Run(run func(ctx context.Context, _a1 graph.ResourceContext, roleFilters []string, sortBy *graph.SortByInput, page *graph.PageInput)) *ResolverService_Users_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(graph.ResourceContext), args[2].([]string), args[3].(*graph.SortByInput), args[4].(*graph.PageInput))
	})
	return _c
}

func (_c *ResolverService_Users_Call) Return(_a0 *graph.UserConnection, _a1 error) *ResolverService_Users_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ResolverService_Users_Call) RunAndReturn(run func(context.Context, graph.ResourceContext, []string, *graph.SortByInput, *graph.PageInput) (*graph.UserConnection, error)) *ResolverService_Users_Call {
	_c.Call.Return(run)
	return _c
}

// NewResolverService creates a new instance of ResolverService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewResolverService(t interface {
	mock.TestingT
	Cleanup(func())
}) *ResolverService {
	mock := &ResolverService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
