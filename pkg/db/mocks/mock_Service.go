// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	db "github.com/openmfp/iam-service/pkg/db"
	graph "github.com/openmfp/iam-service/pkg/graph"

	mock "github.com/stretchr/testify/mock"
)

// Service is an autogenerated mock type for the Service type
type Service struct {
	mock.Mock
}

type Service_Expecter struct {
	mock *mock.Mock
}

func (_m *Service) EXPECT() *Service_Expecter {
	return &Service_Expecter{mock: &_m.Mock}
}

// Close provides a mock function with given fields:
func (_m *Service) Close() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Service_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type Service_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *Service_Expecter) Close() *Service_Close_Call {
	return &Service_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *Service_Close_Call) Run(run func()) *Service_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Service_Close_Call) Return(_a0 error) *Service_Close_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Service_Close_Call) RunAndReturn(run func() error) *Service_Close_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteInvite provides a mock function with given fields: ctx, criteria
func (_m *Service) DeleteInvite(ctx context.Context, criteria db.Invite) error {
	ret := _m.Called(ctx, criteria)

	if len(ret) == 0 {
		panic("no return value specified for DeleteInvite")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, db.Invite) error); ok {
		r0 = rf(ctx, criteria)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Service_DeleteInvite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteInvite'
type Service_DeleteInvite_Call struct {
	*mock.Call
}

// DeleteInvite is a helper method to define mock.On call
//   - ctx context.Context
//   - criteria db.Invite
func (_e *Service_Expecter) DeleteInvite(ctx interface{}, criteria interface{}) *Service_DeleteInvite_Call {
	return &Service_DeleteInvite_Call{Call: _e.mock.On("DeleteInvite", ctx, criteria)}
}

func (_c *Service_DeleteInvite_Call) Run(run func(ctx context.Context, criteria db.Invite)) *Service_DeleteInvite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(db.Invite))
	})
	return _c
}

func (_c *Service_DeleteInvite_Call) Return(_a0 error) *Service_DeleteInvite_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Service_DeleteInvite_Call) RunAndReturn(run func(context.Context, db.Invite) error) *Service_DeleteInvite_Call {
	_c.Call.Return(run)
	return _c
}

// GetInvitesForEntity provides a mock function with given fields: ctx, tenantID, entityType, entityID
func (_m *Service) GetInvitesForEntity(ctx context.Context, tenantID string, entityType string, entityID string) ([]db.Invite, error) {
	ret := _m.Called(ctx, tenantID, entityType, entityID)

	if len(ret) == 0 {
		panic("no return value specified for GetInvitesForEntity")
	}

	var r0 []db.Invite
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) ([]db.Invite, error)); ok {
		return rf(ctx, tenantID, entityType, entityID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) []db.Invite); ok {
		r0 = rf(ctx, tenantID, entityType, entityID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]db.Invite)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, tenantID, entityType, entityID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Service_GetInvitesForEntity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInvitesForEntity'
type Service_GetInvitesForEntity_Call struct {
	*mock.Call
}

// GetInvitesForEntity is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - entityType string
//   - entityID string
func (_e *Service_Expecter) GetInvitesForEntity(ctx interface{}, tenantID interface{}, entityType interface{}, entityID interface{}) *Service_GetInvitesForEntity_Call {
	return &Service_GetInvitesForEntity_Call{Call: _e.mock.On("GetInvitesForEntity", ctx, tenantID, entityType, entityID)}
}

func (_c *Service_GetInvitesForEntity_Call) Run(run func(ctx context.Context, tenantID string, entityType string, entityID string)) *Service_GetInvitesForEntity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *Service_GetInvitesForEntity_Call) Return(_a0 []db.Invite, _a1 error) *Service_GetInvitesForEntity_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Service_GetInvitesForEntity_Call) RunAndReturn(run func(context.Context, string, string, string) ([]db.Invite, error)) *Service_GetInvitesForEntity_Call {
	_c.Call.Return(run)
	return _c
}

// GetOrCreateUser provides a mock function with given fields: ctx, tenantID, input
func (_m *Service) GetOrCreateUser(ctx context.Context, tenantID string, input graph.UserInput) (*graph.User, error) {
	ret := _m.Called(ctx, tenantID, input)

	if len(ret) == 0 {
		panic("no return value specified for GetOrCreateUser")
	}

	var r0 *graph.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, graph.UserInput) (*graph.User, error)); ok {
		return rf(ctx, tenantID, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, graph.UserInput) *graph.User); ok {
		r0 = rf(ctx, tenantID, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*graph.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, graph.UserInput) error); ok {
		r1 = rf(ctx, tenantID, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Service_GetOrCreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOrCreateUser'
type Service_GetOrCreateUser_Call struct {
	*mock.Call
}

// GetOrCreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - input graph.UserInput
func (_e *Service_Expecter) GetOrCreateUser(ctx interface{}, tenantID interface{}, input interface{}) *Service_GetOrCreateUser_Call {
	return &Service_GetOrCreateUser_Call{Call: _e.mock.On("GetOrCreateUser", ctx, tenantID, input)}
}

func (_c *Service_GetOrCreateUser_Call) Run(run func(ctx context.Context, tenantID string, input graph.UserInput)) *Service_GetOrCreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(graph.UserInput))
	})
	return _c
}

func (_c *Service_GetOrCreateUser_Call) Return(_a0 *graph.User, _a1 error) *Service_GetOrCreateUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Service_GetOrCreateUser_Call) RunAndReturn(run func(context.Context, string, graph.UserInput) (*graph.User, error)) *Service_GetOrCreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetRolesByTechnicalNames provides a mock function with given fields: ctx, entityType, technicalNames
func (_m *Service) GetRolesByTechnicalNames(ctx context.Context, entityType string, technicalNames []string) ([]*db.Role, error) {
	ret := _m.Called(ctx, entityType, technicalNames)

	if len(ret) == 0 {
		panic("no return value specified for GetRolesByTechnicalNames")
	}

	var r0 []*db.Role
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) ([]*db.Role, error)); ok {
		return rf(ctx, entityType, technicalNames)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) []*db.Role); ok {
		r0 = rf(ctx, entityType, technicalNames)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*db.Role)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string) error); ok {
		r1 = rf(ctx, entityType, technicalNames)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Service_GetRolesByTechnicalNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRolesByTechnicalNames'
type Service_GetRolesByTechnicalNames_Call struct {
	*mock.Call
}

// GetRolesByTechnicalNames is a helper method to define mock.On call
//   - ctx context.Context
//   - entityType string
//   - technicalNames []string
func (_e *Service_Expecter) GetRolesByTechnicalNames(ctx interface{}, entityType interface{}, technicalNames interface{}) *Service_GetRolesByTechnicalNames_Call {
	return &Service_GetRolesByTechnicalNames_Call{Call: _e.mock.On("GetRolesByTechnicalNames", ctx, entityType, technicalNames)}
}

func (_c *Service_GetRolesByTechnicalNames_Call) Run(run func(ctx context.Context, entityType string, technicalNames []string)) *Service_GetRolesByTechnicalNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string))
	})
	return _c
}

func (_c *Service_GetRolesByTechnicalNames_Call) Return(_a0 []*db.Role, _a1 error) *Service_GetRolesByTechnicalNames_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Service_GetRolesByTechnicalNames_Call) RunAndReturn(run func(context.Context, string, []string) ([]*db.Role, error)) *Service_GetRolesByTechnicalNames_Call {
	_c.Call.Return(run)
	return _c
}

// GetRolesForEntity provides a mock function with given fields: ctx, entityType, entityID
func (_m *Service) GetRolesForEntity(ctx context.Context, entityType string, entityID string) ([]db.Role, error) {
	ret := _m.Called(ctx, entityType, entityID)

	if len(ret) == 0 {
		panic("no return value specified for GetRolesForEntity")
	}

	var r0 []db.Role
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]db.Role, error)); ok {
		return rf(ctx, entityType, entityID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []db.Role); ok {
		r0 = rf(ctx, entityType, entityID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]db.Role)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, entityType, entityID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Service_GetRolesForEntity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRolesForEntity'
type Service_GetRolesForEntity_Call struct {
	*mock.Call
}

// GetRolesForEntity is a helper method to define mock.On call
//   - ctx context.Context
//   - entityType string
//   - entityID string
func (_e *Service_Expecter) GetRolesForEntity(ctx interface{}, entityType interface{}, entityID interface{}) *Service_GetRolesForEntity_Call {
	return &Service_GetRolesForEntity_Call{Call: _e.mock.On("GetRolesForEntity", ctx, entityType, entityID)}
}

func (_c *Service_GetRolesForEntity_Call) Run(run func(ctx context.Context, entityType string, entityID string)) *Service_GetRolesForEntity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Service_GetRolesForEntity_Call) Return(_a0 []db.Role, _a1 error) *Service_GetRolesForEntity_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Service_GetRolesForEntity_Call) RunAndReturn(run func(context.Context, string, string) ([]db.Role, error)) *Service_GetRolesForEntity_Call {
	_c.Call.Return(run)
	return _c
}

// GetTenantConfigurationForContext provides a mock function with given fields: ctx
func (_m *Service) GetTenantConfigurationForContext(ctx context.Context) (*db.TenantConfiguration, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetTenantConfigurationForContext")
	}

	var r0 *db.TenantConfiguration
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*db.TenantConfiguration, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *db.TenantConfiguration); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*db.TenantConfiguration)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Service_GetTenantConfigurationForContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTenantConfigurationForContext'
type Service_GetTenantConfigurationForContext_Call struct {
	*mock.Call
}

// GetTenantConfigurationForContext is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Service_Expecter) GetTenantConfigurationForContext(ctx interface{}) *Service_GetTenantConfigurationForContext_Call {
	return &Service_GetTenantConfigurationForContext_Call{Call: _e.mock.On("GetTenantConfigurationForContext", ctx)}
}

func (_c *Service_GetTenantConfigurationForContext_Call) Run(run func(ctx context.Context)) *Service_GetTenantConfigurationForContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Service_GetTenantConfigurationForContext_Call) Return(_a0 *db.TenantConfiguration, _a1 error) *Service_GetTenantConfigurationForContext_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Service_GetTenantConfigurationForContext_Call) RunAndReturn(run func(context.Context) (*db.TenantConfiguration, error)) *Service_GetTenantConfigurationForContext_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByEmail provides a mock function with given fields: ctx, tenantID, email
func (_m *Service) GetUserByEmail(ctx context.Context, tenantID string, email string) (*graph.User, error) {
	ret := _m.Called(ctx, tenantID, email)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByEmail")
	}

	var r0 *graph.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*graph.User, error)); ok {
		return rf(ctx, tenantID, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *graph.User); ok {
		r0 = rf(ctx, tenantID, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*graph.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, tenantID, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Service_GetUserByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByEmail'
type Service_GetUserByEmail_Call struct {
	*mock.Call
}

// GetUserByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - email string
func (_e *Service_Expecter) GetUserByEmail(ctx interface{}, tenantID interface{}, email interface{}) *Service_GetUserByEmail_Call {
	return &Service_GetUserByEmail_Call{Call: _e.mock.On("GetUserByEmail", ctx, tenantID, email)}
}

func (_c *Service_GetUserByEmail_Call) Run(run func(ctx context.Context, tenantID string, email string)) *Service_GetUserByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Service_GetUserByEmail_Call) Return(_a0 *graph.User, _a1 error) *Service_GetUserByEmail_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Service_GetUserByEmail_Call) RunAndReturn(run func(context.Context, string, string) (*graph.User, error)) *Service_GetUserByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByID provides a mock function with given fields: ctx, tenantID, userId
func (_m *Service) GetUserByID(ctx context.Context, tenantID string, userId string) (*graph.User, error) {
	ret := _m.Called(ctx, tenantID, userId)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByID")
	}

	var r0 *graph.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*graph.User, error)); ok {
		return rf(ctx, tenantID, userId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *graph.User); ok {
		r0 = rf(ctx, tenantID, userId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*graph.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, tenantID, userId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Service_GetUserByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByID'
type Service_GetUserByID_Call struct {
	*mock.Call
}

// GetUserByID is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - userId string
func (_e *Service_Expecter) GetUserByID(ctx interface{}, tenantID interface{}, userId interface{}) *Service_GetUserByID_Call {
	return &Service_GetUserByID_Call{Call: _e.mock.On("GetUserByID", ctx, tenantID, userId)}
}

func (_c *Service_GetUserByID_Call) Run(run func(ctx context.Context, tenantID string, userId string)) *Service_GetUserByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Service_GetUserByID_Call) Return(_a0 *graph.User, _a1 error) *Service_GetUserByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Service_GetUserByID_Call) RunAndReturn(run func(context.Context, string, string) (*graph.User, error)) *Service_GetUserByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserHooks provides a mock function with given fields:
func (_m *Service) GetUserHooks() db.UserHooks {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetUserHooks")
	}

	var r0 db.UserHooks
	if rf, ok := ret.Get(0).(func() db.UserHooks); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(db.UserHooks)
		}
	}

	return r0
}

// Service_GetUserHooks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserHooks'
type Service_GetUserHooks_Call struct {
	*mock.Call
}

// GetUserHooks is a helper method to define mock.On call
func (_e *Service_Expecter) GetUserHooks() *Service_GetUserHooks_Call {
	return &Service_GetUserHooks_Call{Call: _e.mock.On("GetUserHooks")}
}

func (_c *Service_GetUserHooks_Call) Run(run func()) *Service_GetUserHooks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Service_GetUserHooks_Call) Return(_a0 db.UserHooks) *Service_GetUserHooks_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Service_GetUserHooks_Call) RunAndReturn(run func() db.UserHooks) *Service_GetUserHooks_Call {
	_c.Call.Return(run)
	return _c
}

// GetUsers provides a mock function with given fields: ctx, tenantID, limit, page
func (_m *Service) GetUsers(ctx context.Context, tenantID string, limit int, page int) (*graph.UserConnection, error) {
	ret := _m.Called(ctx, tenantID, limit, page)

	if len(ret) == 0 {
		panic("no return value specified for GetUsers")
	}

	var r0 *graph.UserConnection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) (*graph.UserConnection, error)); ok {
		return rf(ctx, tenantID, limit, page)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) *graph.UserConnection); ok {
		r0 = rf(ctx, tenantID, limit, page)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*graph.UserConnection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, int) error); ok {
		r1 = rf(ctx, tenantID, limit, page)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Service_GetUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUsers'
type Service_GetUsers_Call struct {
	*mock.Call
}

// GetUsers is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - limit int
//   - page int
func (_e *Service_Expecter) GetUsers(ctx interface{}, tenantID interface{}, limit interface{}, page interface{}) *Service_GetUsers_Call {
	return &Service_GetUsers_Call{Call: _e.mock.On("GetUsers", ctx, tenantID, limit, page)}
}

func (_c *Service_GetUsers_Call) Run(run func(ctx context.Context, tenantID string, limit int, page int)) *Service_GetUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *Service_GetUsers_Call) Return(_a0 *graph.UserConnection, _a1 error) *Service_GetUsers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Service_GetUsers_Call) RunAndReturn(run func(context.Context, string, int, int) (*graph.UserConnection, error)) *Service_GetUsers_Call {
	_c.Call.Return(run)
	return _c
}

// GetUsersByUserIDs provides a mock function with given fields: ctx, tenantID, userIDs, limit, page
func (_m *Service) GetUsersByUserIDs(ctx context.Context, tenantID string, userIDs []string, limit int, page int) ([]*graph.User, error) {
	ret := _m.Called(ctx, tenantID, userIDs, limit, page)

	if len(ret) == 0 {
		panic("no return value specified for GetUsersByUserIDs")
	}

	var r0 []*graph.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, int, int) ([]*graph.User, error)); ok {
		return rf(ctx, tenantID, userIDs, limit, page)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, int, int) []*graph.User); ok {
		r0 = rf(ctx, tenantID, userIDs, limit, page)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*graph.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, int, int) error); ok {
		r1 = rf(ctx, tenantID, userIDs, limit, page)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Service_GetUsersByUserIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUsersByUserIDs'
type Service_GetUsersByUserIDs_Call struct {
	*mock.Call
}

// GetUsersByUserIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - userIDs []string
//   - limit int
//   - page int
func (_e *Service_Expecter) GetUsersByUserIDs(ctx interface{}, tenantID interface{}, userIDs interface{}, limit interface{}, page interface{}) *Service_GetUsersByUserIDs_Call {
	return &Service_GetUsersByUserIDs_Call{Call: _e.mock.On("GetUsersByUserIDs", ctx, tenantID, userIDs, limit, page)}
}

func (_c *Service_GetUsersByUserIDs_Call) Run(run func(ctx context.Context, tenantID string, userIDs []string, limit int, page int)) *Service_GetUsersByUserIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string), args[3].(int), args[4].(int))
	})
	return _c
}

func (_c *Service_GetUsersByUserIDs_Call) Return(_a0 []*graph.User, _a1 error) *Service_GetUsersByUserIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Service_GetUsersByUserIDs_Call) RunAndReturn(run func(context.Context, string, []string, int, int) ([]*graph.User, error)) *Service_GetUsersByUserIDs_Call {
	_c.Call.Return(run)
	return _c
}

// InviteUser provides a mock function with given fields: ctx, tenantID, invite, notifyByEmail
func (_m *Service) InviteUser(ctx context.Context, tenantID string, invite graph.Invite, notifyByEmail bool) error {
	ret := _m.Called(ctx, tenantID, invite, notifyByEmail)

	if len(ret) == 0 {
		panic("no return value specified for InviteUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, graph.Invite, bool) error); ok {
		r0 = rf(ctx, tenantID, invite, notifyByEmail)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Service_InviteUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InviteUser'
type Service_InviteUser_Call struct {
	*mock.Call
}

// InviteUser is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - invite graph.Invite
//   - notifyByEmail bool
func (_e *Service_Expecter) InviteUser(ctx interface{}, tenantID interface{}, invite interface{}, notifyByEmail interface{}) *Service_InviteUser_Call {
	return &Service_InviteUser_Call{Call: _e.mock.On("InviteUser", ctx, tenantID, invite, notifyByEmail)}
}

func (_c *Service_InviteUser_Call) Run(run func(ctx context.Context, tenantID string, invite graph.Invite, notifyByEmail bool)) *Service_InviteUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(graph.Invite), args[3].(bool))
	})
	return _c
}

func (_c *Service_InviteUser_Call) Return(_a0 error) *Service_InviteUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Service_InviteUser_Call) RunAndReturn(run func(context.Context, string, graph.Invite, bool) error) *Service_InviteUser_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveRoleFromInvite provides a mock function with given fields: ctx, criteria, roleToDelete
func (_m *Service) RemoveRoleFromInvite(ctx context.Context, criteria db.Invite, roleToDelete string) error {
	ret := _m.Called(ctx, criteria, roleToDelete)

	if len(ret) == 0 {
		panic("no return value specified for RemoveRoleFromInvite")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, db.Invite, string) error); ok {
		r0 = rf(ctx, criteria, roleToDelete)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Service_RemoveRoleFromInvite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveRoleFromInvite'
type Service_RemoveRoleFromInvite_Call struct {
	*mock.Call
}

// RemoveRoleFromInvite is a helper method to define mock.On call
//   - ctx context.Context
//   - criteria db.Invite
//   - roleToDelete string
func (_e *Service_Expecter) RemoveRoleFromInvite(ctx interface{}, criteria interface{}, roleToDelete interface{}) *Service_RemoveRoleFromInvite_Call {
	return &Service_RemoveRoleFromInvite_Call{Call: _e.mock.On("RemoveRoleFromInvite", ctx, criteria, roleToDelete)}
}

func (_c *Service_RemoveRoleFromInvite_Call) Run(run func(ctx context.Context, criteria db.Invite, roleToDelete string)) *Service_RemoveRoleFromInvite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(db.Invite), args[2].(string))
	})
	return _c
}

func (_c *Service_RemoveRoleFromInvite_Call) Return(_a0 error) *Service_RemoveRoleFromInvite_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Service_RemoveRoleFromInvite_Call) RunAndReturn(run func(context.Context, db.Invite, string) error) *Service_RemoveRoleFromInvite_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveUser provides a mock function with given fields: ctx, tenantID, userId, email
func (_m *Service) RemoveUser(ctx context.Context, tenantID string, userId string, email string) (bool, error) {
	ret := _m.Called(ctx, tenantID, userId, email)

	if len(ret) == 0 {
		panic("no return value specified for RemoveUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (bool, error)); ok {
		return rf(ctx, tenantID, userId, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) bool); ok {
		r0 = rf(ctx, tenantID, userId, email)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, tenantID, userId, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Service_RemoveUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveUser'
type Service_RemoveUser_Call struct {
	*mock.Call
}

// RemoveUser is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - userId string
//   - email string
func (_e *Service_Expecter) RemoveUser(ctx interface{}, tenantID interface{}, userId interface{}, email interface{}) *Service_RemoveUser_Call {
	return &Service_RemoveUser_Call{Call: _e.mock.On("RemoveUser", ctx, tenantID, userId, email)}
}

func (_c *Service_RemoveUser_Call) Run(run func(ctx context.Context, tenantID string, userId string, email string)) *Service_RemoveUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *Service_RemoveUser_Call) Return(_a0 bool, _a1 error) *Service_RemoveUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Service_RemoveUser_Call) RunAndReturn(run func(context.Context, string, string, string) (bool, error)) *Service_RemoveUser_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function with given fields: user
func (_m *Service) Save(user *graph.User) error {
	ret := _m.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*graph.User) error); ok {
		r0 = rf(user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Service_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type Service_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - user *graph.User
func (_e *Service_Expecter) Save(user interface{}) *Service_Save_Call {
	return &Service_Save_Call{Call: _e.mock.On("Save", user)}
}

func (_c *Service_Save_Call) Run(run func(user *graph.User)) *Service_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*graph.User))
	})
	return _c
}

func (_c *Service_Save_Call) Return(_a0 error) *Service_Save_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Service_Save_Call) RunAndReturn(run func(*graph.User) error) *Service_Save_Call {
	_c.Call.Return(run)
	return _c
}

// SetUserHooks provides a mock function with given fields: hooks
func (_m *Service) SetUserHooks(hooks db.UserHooks) {
	_m.Called(hooks)
}

// Service_SetUserHooks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetUserHooks'
type Service_SetUserHooks_Call struct {
	*mock.Call
}

// SetUserHooks is a helper method to define mock.On call
//   - hooks db.UserHooks
func (_e *Service_Expecter) SetUserHooks(hooks interface{}) *Service_SetUserHooks_Call {
	return &Service_SetUserHooks_Call{Call: _e.mock.On("SetUserHooks", hooks)}
}

func (_c *Service_SetUserHooks_Call) Run(run func(hooks db.UserHooks)) *Service_SetUserHooks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(db.UserHooks))
	})
	return _c
}

func (_c *Service_SetUserHooks_Call) Return() *Service_SetUserHooks_Call {
	_c.Call.Return()
	return _c
}

func (_c *Service_SetUserHooks_Call) RunAndReturn(run func(db.UserHooks)) *Service_SetUserHooks_Call {
	_c.Call.Return(run)
	return _c
}

// NewService creates a new instance of Service. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewService(t interface {
	mock.TestingT
	Cleanup(func())
}) *Service {
	mock := &Service{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
