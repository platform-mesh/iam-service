// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	graph "github.com/openmfp/iam-service/pkg/graph"
	mock "github.com/stretchr/testify/mock"
)

// QueryResolver is an autogenerated mock type for the QueryResolver type
type QueryResolver struct {
	mock.Mock
}

type QueryResolver_Expecter struct {
	mock *mock.Mock
}

func (_m *QueryResolver) EXPECT() *QueryResolver_Expecter {
	return &QueryResolver_Expecter{mock: &_m.Mock}
}

// AvailableRolesForEntity provides a mock function with given fields: ctx, tenantID, entity
func (_m *QueryResolver) AvailableRolesForEntity(ctx context.Context, tenantID string, entity graph.EntityInput) ([]*graph.Role, error) {
	ret := _m.Called(ctx, tenantID, entity)

	if len(ret) == 0 {
		panic("no return value specified for AvailableRolesForEntity")
	}

	var r0 []*graph.Role
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, graph.EntityInput) ([]*graph.Role, error)); ok {
		return rf(ctx, tenantID, entity)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, graph.EntityInput) []*graph.Role); ok {
		r0 = rf(ctx, tenantID, entity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*graph.Role)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, graph.EntityInput) error); ok {
		r1 = rf(ctx, tenantID, entity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryResolver_AvailableRolesForEntity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AvailableRolesForEntity'
type QueryResolver_AvailableRolesForEntity_Call struct {
	*mock.Call
}

// AvailableRolesForEntity is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - entity graph.EntityInput
func (_e *QueryResolver_Expecter) AvailableRolesForEntity(ctx interface{}, tenantID interface{}, entity interface{}) *QueryResolver_AvailableRolesForEntity_Call {
	return &QueryResolver_AvailableRolesForEntity_Call{Call: _e.mock.On("AvailableRolesForEntity", ctx, tenantID, entity)}
}

func (_c *QueryResolver_AvailableRolesForEntity_Call) Run(run func(ctx context.Context, tenantID string, entity graph.EntityInput)) *QueryResolver_AvailableRolesForEntity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(graph.EntityInput))
	})
	return _c
}

func (_c *QueryResolver_AvailableRolesForEntity_Call) Return(_a0 []*graph.Role, _a1 error) *QueryResolver_AvailableRolesForEntity_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *QueryResolver_AvailableRolesForEntity_Call) RunAndReturn(run func(context.Context, string, graph.EntityInput) ([]*graph.Role, error)) *QueryResolver_AvailableRolesForEntity_Call {
	_c.Call.Return(run)
	return _c
}

// AvailableRolesForEntityType provides a mock function with given fields: ctx, tenantID, entityType
func (_m *QueryResolver) AvailableRolesForEntityType(ctx context.Context, tenantID string, entityType string) ([]*graph.Role, error) {
	ret := _m.Called(ctx, tenantID, entityType)

	if len(ret) == 0 {
		panic("no return value specified for AvailableRolesForEntityType")
	}

	var r0 []*graph.Role
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]*graph.Role, error)); ok {
		return rf(ctx, tenantID, entityType)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []*graph.Role); ok {
		r0 = rf(ctx, tenantID, entityType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*graph.Role)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, tenantID, entityType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryResolver_AvailableRolesForEntityType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AvailableRolesForEntityType'
type QueryResolver_AvailableRolesForEntityType_Call struct {
	*mock.Call
}

// AvailableRolesForEntityType is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - entityType string
func (_e *QueryResolver_Expecter) AvailableRolesForEntityType(ctx interface{}, tenantID interface{}, entityType interface{}) *QueryResolver_AvailableRolesForEntityType_Call {
	return &QueryResolver_AvailableRolesForEntityType_Call{Call: _e.mock.On("AvailableRolesForEntityType", ctx, tenantID, entityType)}
}

func (_c *QueryResolver_AvailableRolesForEntityType_Call) Run(run func(ctx context.Context, tenantID string, entityType string)) *QueryResolver_AvailableRolesForEntityType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *QueryResolver_AvailableRolesForEntityType_Call) Return(_a0 []*graph.Role, _a1 error) *QueryResolver_AvailableRolesForEntityType_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *QueryResolver_AvailableRolesForEntityType_Call) RunAndReturn(run func(context.Context, string, string) ([]*graph.Role, error)) *QueryResolver_AvailableRolesForEntityType_Call {
	_c.Call.Return(run)
	return _c
}

// RolesForUserOfEntity provides a mock function with given fields: ctx, tenantID, entity, userID
func (_m *QueryResolver) RolesForUserOfEntity(ctx context.Context, tenantID string, entity graph.EntityInput, userID string) ([]*graph.Role, error) {
	ret := _m.Called(ctx, tenantID, entity, userID)

	if len(ret) == 0 {
		panic("no return value specified for RolesForUserOfEntity")
	}

	var r0 []*graph.Role
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, graph.EntityInput, string) ([]*graph.Role, error)); ok {
		return rf(ctx, tenantID, entity, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, graph.EntityInput, string) []*graph.Role); ok {
		r0 = rf(ctx, tenantID, entity, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*graph.Role)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, graph.EntityInput, string) error); ok {
		r1 = rf(ctx, tenantID, entity, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryResolver_RolesForUserOfEntity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RolesForUserOfEntity'
type QueryResolver_RolesForUserOfEntity_Call struct {
	*mock.Call
}

// RolesForUserOfEntity is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - entity graph.EntityInput
//   - userID string
func (_e *QueryResolver_Expecter) RolesForUserOfEntity(ctx interface{}, tenantID interface{}, entity interface{}, userID interface{}) *QueryResolver_RolesForUserOfEntity_Call {
	return &QueryResolver_RolesForUserOfEntity_Call{Call: _e.mock.On("RolesForUserOfEntity", ctx, tenantID, entity, userID)}
}

func (_c *QueryResolver_RolesForUserOfEntity_Call) Run(run func(ctx context.Context, tenantID string, entity graph.EntityInput, userID string)) *QueryResolver_RolesForUserOfEntity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(graph.EntityInput), args[3].(string))
	})
	return _c
}

func (_c *QueryResolver_RolesForUserOfEntity_Call) Return(_a0 []*graph.Role, _a1 error) *QueryResolver_RolesForUserOfEntity_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *QueryResolver_RolesForUserOfEntity_Call) RunAndReturn(run func(context.Context, string, graph.EntityInput, string) ([]*graph.Role, error)) *QueryResolver_RolesForUserOfEntity_Call {
	_c.Call.Return(run)
	return _c
}

// TeamByName provides a mock function with given fields: ctx, tenantID, teamName
func (_m *QueryResolver) TeamByName(ctx context.Context, tenantID string, teamName string) (*graph.Team, error) {
	ret := _m.Called(ctx, tenantID, teamName)

	if len(ret) == 0 {
		panic("no return value specified for TeamByName")
	}

	var r0 *graph.Team
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*graph.Team, error)); ok {
		return rf(ctx, tenantID, teamName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *graph.Team); ok {
		r0 = rf(ctx, tenantID, teamName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*graph.Team)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, tenantID, teamName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryResolver_TeamByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TeamByName'
type QueryResolver_TeamByName_Call struct {
	*mock.Call
}

// TeamByName is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - teamName string
func (_e *QueryResolver_Expecter) TeamByName(ctx interface{}, tenantID interface{}, teamName interface{}) *QueryResolver_TeamByName_Call {
	return &QueryResolver_TeamByName_Call{Call: _e.mock.On("TeamByName", ctx, tenantID, teamName)}
}

func (_c *QueryResolver_TeamByName_Call) Run(run func(ctx context.Context, tenantID string, teamName string)) *QueryResolver_TeamByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *QueryResolver_TeamByName_Call) Return(_a0 *graph.Team, _a1 error) *QueryResolver_TeamByName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *QueryResolver_TeamByName_Call) RunAndReturn(run func(context.Context, string, string) (*graph.Team, error)) *QueryResolver_TeamByName_Call {
	_c.Call.Return(run)
	return _c
}

// Teams provides a mock function with given fields: ctx, tenantID, limit, page
func (_m *QueryResolver) Teams(ctx context.Context, tenantID string, limit *int, page *int) (*graph.TeamConnection, error) {
	ret := _m.Called(ctx, tenantID, limit, page)

	if len(ret) == 0 {
		panic("no return value specified for Teams")
	}

	var r0 *graph.TeamConnection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *int, *int) (*graph.TeamConnection, error)); ok {
		return rf(ctx, tenantID, limit, page)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *int, *int) *graph.TeamConnection); ok {
		r0 = rf(ctx, tenantID, limit, page)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*graph.TeamConnection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *int, *int) error); ok {
		r1 = rf(ctx, tenantID, limit, page)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryResolver_Teams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Teams'
type QueryResolver_Teams_Call struct {
	*mock.Call
}

// Teams is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - limit *int
//   - page *int
func (_e *QueryResolver_Expecter) Teams(ctx interface{}, tenantID interface{}, limit interface{}, page interface{}) *QueryResolver_Teams_Call {
	return &QueryResolver_Teams_Call{Call: _e.mock.On("Teams", ctx, tenantID, limit, page)}
}

func (_c *QueryResolver_Teams_Call) Run(run func(ctx context.Context, tenantID string, limit *int, page *int)) *QueryResolver_Teams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*int), args[3].(*int))
	})
	return _c
}

func (_c *QueryResolver_Teams_Call) Return(_a0 *graph.TeamConnection, _a1 error) *QueryResolver_Teams_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *QueryResolver_Teams_Call) RunAndReturn(run func(context.Context, string, *int, *int) (*graph.TeamConnection, error)) *QueryResolver_Teams_Call {
	_c.Call.Return(run)
	return _c
}

// TenantInfo provides a mock function with given fields: ctx, tenantID
func (_m *QueryResolver) TenantInfo(ctx context.Context, tenantID *string) (*graph.TenantInfo, error) {
	ret := _m.Called(ctx, tenantID)

	if len(ret) == 0 {
		panic("no return value specified for TenantInfo")
	}

	var r0 *graph.TenantInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *string) (*graph.TenantInfo, error)); ok {
		return rf(ctx, tenantID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *string) *graph.TenantInfo); ok {
		r0 = rf(ctx, tenantID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*graph.TenantInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *string) error); ok {
		r1 = rf(ctx, tenantID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryResolver_TenantInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TenantInfo'
type QueryResolver_TenantInfo_Call struct {
	*mock.Call
}

// TenantInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID *string
func (_e *QueryResolver_Expecter) TenantInfo(ctx interface{}, tenantID interface{}) *QueryResolver_TenantInfo_Call {
	return &QueryResolver_TenantInfo_Call{Call: _e.mock.On("TenantInfo", ctx, tenantID)}
}

func (_c *QueryResolver_TenantInfo_Call) Run(run func(ctx context.Context, tenantID *string)) *QueryResolver_TenantInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*string))
	})
	return _c
}

func (_c *QueryResolver_TenantInfo_Call) Return(_a0 *graph.TenantInfo, _a1 error) *QueryResolver_TenantInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *QueryResolver_TenantInfo_Call) RunAndReturn(run func(context.Context, *string) (*graph.TenantInfo, error)) *QueryResolver_TenantInfo_Call {
	_c.Call.Return(run)
	return _c
}

// User provides a mock function with given fields: ctx, tenantID, userID
func (_m *QueryResolver) User(ctx context.Context, tenantID string, userID string) (*graph.User, error) {
	ret := _m.Called(ctx, tenantID, userID)

	if len(ret) == 0 {
		panic("no return value specified for User")
	}

	var r0 *graph.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*graph.User, error)); ok {
		return rf(ctx, tenantID, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *graph.User); ok {
		r0 = rf(ctx, tenantID, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*graph.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, tenantID, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryResolver_User_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'User'
type QueryResolver_User_Call struct {
	*mock.Call
}

// User is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - userID string
func (_e *QueryResolver_Expecter) User(ctx interface{}, tenantID interface{}, userID interface{}) *QueryResolver_User_Call {
	return &QueryResolver_User_Call{Call: _e.mock.On("User", ctx, tenantID, userID)}
}

func (_c *QueryResolver_User_Call) Run(run func(ctx context.Context, tenantID string, userID string)) *QueryResolver_User_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *QueryResolver_User_Call) Return(_a0 *graph.User, _a1 error) *QueryResolver_User_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *QueryResolver_User_Call) RunAndReturn(run func(context.Context, string, string) (*graph.User, error)) *QueryResolver_User_Call {
	_c.Call.Return(run)
	return _c
}

// UserByEmail provides a mock function with given fields: ctx, tenantID, email
func (_m *QueryResolver) UserByEmail(ctx context.Context, tenantID string, email string) (*graph.User, error) {
	ret := _m.Called(ctx, tenantID, email)

	if len(ret) == 0 {
		panic("no return value specified for UserByEmail")
	}

	var r0 *graph.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*graph.User, error)); ok {
		return rf(ctx, tenantID, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *graph.User); ok {
		r0 = rf(ctx, tenantID, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*graph.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, tenantID, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryResolver_UserByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UserByEmail'
type QueryResolver_UserByEmail_Call struct {
	*mock.Call
}

// UserByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - email string
func (_e *QueryResolver_Expecter) UserByEmail(ctx interface{}, tenantID interface{}, email interface{}) *QueryResolver_UserByEmail_Call {
	return &QueryResolver_UserByEmail_Call{Call: _e.mock.On("UserByEmail", ctx, tenantID, email)}
}

func (_c *QueryResolver_UserByEmail_Call) Run(run func(ctx context.Context, tenantID string, email string)) *QueryResolver_UserByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *QueryResolver_UserByEmail_Call) Return(_a0 *graph.User, _a1 error) *QueryResolver_UserByEmail_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *QueryResolver_UserByEmail_Call) RunAndReturn(run func(context.Context, string, string) (*graph.User, error)) *QueryResolver_UserByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// UsersConnection provides a mock function with given fields: ctx, tenantID, limit, page
func (_m *QueryResolver) UsersConnection(ctx context.Context, tenantID string, limit *int, page *int) (*graph.UserConnection, error) {
	ret := _m.Called(ctx, tenantID, limit, page)

	if len(ret) == 0 {
		panic("no return value specified for UsersConnection")
	}

	var r0 *graph.UserConnection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *int, *int) (*graph.UserConnection, error)); ok {
		return rf(ctx, tenantID, limit, page)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *int, *int) *graph.UserConnection); ok {
		r0 = rf(ctx, tenantID, limit, page)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*graph.UserConnection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *int, *int) error); ok {
		r1 = rf(ctx, tenantID, limit, page)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryResolver_UsersConnection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UsersConnection'
type QueryResolver_UsersConnection_Call struct {
	*mock.Call
}

// UsersConnection is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - limit *int
//   - page *int
func (_e *QueryResolver_Expecter) UsersConnection(ctx interface{}, tenantID interface{}, limit interface{}, page interface{}) *QueryResolver_UsersConnection_Call {
	return &QueryResolver_UsersConnection_Call{Call: _e.mock.On("UsersConnection", ctx, tenantID, limit, page)}
}

func (_c *QueryResolver_UsersConnection_Call) Run(run func(ctx context.Context, tenantID string, limit *int, page *int)) *QueryResolver_UsersConnection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*int), args[3].(*int))
	})
	return _c
}

func (_c *QueryResolver_UsersConnection_Call) Return(_a0 *graph.UserConnection, _a1 error) *QueryResolver_UsersConnection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *QueryResolver_UsersConnection_Call) RunAndReturn(run func(context.Context, string, *int, *int) (*graph.UserConnection, error)) *QueryResolver_UsersConnection_Call {
	_c.Call.Return(run)
	return _c
}

// UsersOfEntity provides a mock function with given fields: ctx, tenantID, entity, limit, page, showInvitees
func (_m *QueryResolver) UsersOfEntity(ctx context.Context, tenantID string, entity graph.EntityInput, limit *int, page *int, showInvitees *bool) (*graph.GrantedUserConnection, error) {
	ret := _m.Called(ctx, tenantID, entity, limit, page, showInvitees)

	if len(ret) == 0 {
		panic("no return value specified for UsersOfEntity")
	}

	var r0 *graph.GrantedUserConnection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, graph.EntityInput, *int, *int, *bool) (*graph.GrantedUserConnection, error)); ok {
		return rf(ctx, tenantID, entity, limit, page, showInvitees)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, graph.EntityInput, *int, *int, *bool) *graph.GrantedUserConnection); ok {
		r0 = rf(ctx, tenantID, entity, limit, page, showInvitees)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*graph.GrantedUserConnection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, graph.EntityInput, *int, *int, *bool) error); ok {
		r1 = rf(ctx, tenantID, entity, limit, page, showInvitees)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryResolver_UsersOfEntity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UsersOfEntity'
type QueryResolver_UsersOfEntity_Call struct {
	*mock.Call
}

// UsersOfEntity is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - entity graph.EntityInput
//   - limit *int
//   - page *int
//   - showInvitees *bool
func (_e *QueryResolver_Expecter) UsersOfEntity(ctx interface{}, tenantID interface{}, entity interface{}, limit interface{}, page interface{}, showInvitees interface{}) *QueryResolver_UsersOfEntity_Call {
	return &QueryResolver_UsersOfEntity_Call{Call: _e.mock.On("UsersOfEntity", ctx, tenantID, entity, limit, page, showInvitees)}
}

func (_c *QueryResolver_UsersOfEntity_Call) Run(run func(ctx context.Context, tenantID string, entity graph.EntityInput, limit *int, page *int, showInvitees *bool)) *QueryResolver_UsersOfEntity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(graph.EntityInput), args[3].(*int), args[4].(*int), args[5].(*bool))
	})
	return _c
}

func (_c *QueryResolver_UsersOfEntity_Call) Return(_a0 *graph.GrantedUserConnection, _a1 error) *QueryResolver_UsersOfEntity_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *QueryResolver_UsersOfEntity_Call) RunAndReturn(run func(context.Context, string, graph.EntityInput, *int, *int, *bool) (*graph.GrantedUserConnection, error)) *QueryResolver_UsersOfEntity_Call {
	_c.Call.Return(run)
	return _c
}

// ZoneByZoneID provides a mock function with given fields: ctx, zoneID
func (_m *QueryResolver) ZoneByZoneID(ctx context.Context, zoneID string) (*graph.Zone, error) {
	ret := _m.Called(ctx, zoneID)

	if len(ret) == 0 {
		panic("no return value specified for ZoneByZoneID")
	}

	var r0 *graph.Zone
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*graph.Zone, error)); ok {
		return rf(ctx, zoneID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *graph.Zone); ok {
		r0 = rf(ctx, zoneID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*graph.Zone)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, zoneID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryResolver_ZoneByZoneID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZoneByZoneID'
type QueryResolver_ZoneByZoneID_Call struct {
	*mock.Call
}

// ZoneByZoneID is a helper method to define mock.On call
//   - ctx context.Context
//   - zoneID string
func (_e *QueryResolver_Expecter) ZoneByZoneID(ctx interface{}, zoneID interface{}) *QueryResolver_ZoneByZoneID_Call {
	return &QueryResolver_ZoneByZoneID_Call{Call: _e.mock.On("ZoneByZoneID", ctx, zoneID)}
}

func (_c *QueryResolver_ZoneByZoneID_Call) Run(run func(ctx context.Context, zoneID string)) *QueryResolver_ZoneByZoneID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *QueryResolver_ZoneByZoneID_Call) Return(_a0 *graph.Zone, _a1 error) *QueryResolver_ZoneByZoneID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *QueryResolver_ZoneByZoneID_Call) RunAndReturn(run func(context.Context, string) (*graph.Zone, error)) *QueryResolver_ZoneByZoneID_Call {
	_c.Call.Return(run)
	return _c
}

// NewQueryResolver creates a new instance of QueryResolver. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewQueryResolver(t interface {
	mock.TestingT
	Cleanup(func())
}) *QueryResolver {
	mock := &QueryResolver{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
